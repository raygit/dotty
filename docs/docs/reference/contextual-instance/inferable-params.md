---
layout: doc-page
title: "Given Clauses"
---

Functional programming tends to express most dependencies as simple function parameterization.
This is clean and powerful, but it sometimes leads to functions that take many parameters and
call trees where the same value is passed over and over again in long call chains to many
functions. Given clauses can help here since they enable the compiler to synthesize
repetitive arguments instead of the programmer having to write them explicitly.

For example, given the [instance definitions](./instance-defs.md) of the previous section,
a maximum function that works for any arguments for which an ordering exists can be defined as follows:
```scala
def max[T](x: T, y: T) given (ord: Ord[T]): T =
  if (ord.compare(x, y) < 1) y else x
```
Here, the part following `given` introduces a constraint that `T` is ordered, or, otherwise put, that an implicit instance for `Ord[T]` exists.
That instance is passed as an _implicit parameter_ to the method. Inside the method, the implicit instance can be accessed under the name `ord`.

The `max` method can be applied as follows:
```scala
max(2, 3) given IntOrd
```
The `given IntOrd` part establishes `IntOrd` as the instance to satisfy the constraint `Ord[Int]`.
It does this by providing the `IntOrd` value as as an argument for the implicit `ord` parameter.
But the point of implicit parameters is that this argument can also be left out (and it usually is).
So the following applications are equally valid:
```scala
max(2, 3)
max(List(1, 2, 3), Nil)
```

## Anonymous Inferable Parameters

In many situations, the name of an implicit parameter of a method need not be mentioned explicitly at all,
since it is only used as a synthesized instance for other constraints. In that case one can avoid defining
a parameter name and just provide its type. Example:
```scala
def maximum[T](xs: List[T]) given Ord[T]: T =
  xs.reduceLeft(max)
```
`maximum` takes an implicit parameter of type `Ord` only to pass it on as an implicit argument to `max`. The name of the parameter is left out.

Generally, implicit parameters may be given either as a parameter list `(p_1: T_1, ..., p_n: T_n)` or as a sequence of types, separated by commas.

## Inferring Complex Arguments

Here are two other methods that require implicits of type `Ord[T]`:
```scala
def descending[T] given (asc: Ord[T]): Ord[T] = new Ord[T] {
  def compare(x: T, y: T) = asc.compare(y, x)
}

def minimum[T](xs: List[T]) given Ord[T] =
  maximum(xs) given descending
```
The `minimum` method's right hand side passes `descending` as an explicit argument to `maximum(xs)`.
With this setup, the following calls are all well-formed, and they all normalize to the last one:
```scala
minimum(xs)
maximum(xs) given descending
maximum(xs) given (descending given ListOrd)
maximum(xs) given (descending given (ListOrd given IntOrd))
```

## Mixing Inferable And Normal Parameters

Inferable parameters can be freely mixed with normal parameters.
An inferable parameter may be followed by a normal parameter and _vice versa_.
There can be several inferable parameter lists in a definition. Example:
```scala
def f given (u: Universe) (x: u.T) given Context = ...

instance global of Universe { type T = String ... }
instance ctx of Context { ... }
```
Then the following calls are all valid (and normalize to the last one)
```scala
f("abc")
(f given global)("abc")
f("abc") given ctx
(f given global)("abc") given ctx
```

## Summoning Instances

A method `the` in `Predef` summons the implicit instance for a given type. For example, the instance for `Ord[List[Int]]` is generated by
```scala
the[Ord[List[Int]]]  // reduces to ListOrd given IntOrd
```
The `the` method is simply defined as the (non-widening) identity function over an implicit parameter.
```scala
def the[T] given (x: T): x.type = x
```
Functions like `the` that have only implicit parameters are also called _context queries_.

## Syntax

Here is the new syntax of parameters and arguments seen as a delta from the [standard context free syntax of Scala 3](http://dotty.epfl.ch/docs/internals/syntax.html).
```
ClsParamClause    ::=  ...
                    |  ‘given’ (‘(’ [ClsParams] ‘)’ | GivenTypes)
DefParamClause    ::=  ...
                    |  GivenParamClause
GivenParamClause  ::=  ‘given’ (‘(’ DefParams ‘)’ | GivenTypes)
GivenTypes        ::=  AnnotType {‘,’ AnnotType}

InfixExpr         ::=  ...
                    |  InfixExpr ‘given’ (InfixExpr | ParArgumentExprs)
```
